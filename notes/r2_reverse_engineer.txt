TryHackMe Christmas Advent - Day 17 Walkthrough
    Taking notes to better understand r2, reverse engineering, and exploit development

[*] Run r2 on our executable file:

elfmceager@tbfc-day-17:~$ r2 -d ./file1 
Process with PID 1439 started...
= attach 1439 1439
bin.baddr 0x00400000
Using 0x400000
Warning: Cannot initialize dynamic strings
asm.bits 64


[*] Analyze the file, this can take time:

0x00400a30]> aa
[ WARNING : block size exceeding max block size at 0x006ba220
[+] Try changing it with e anal.bb.maxsize
 WARNING : block size exceeding max block size at 0x006bc860
[+] Try changing it with e anal.bb.maxsize
[x] Analyze all flags starting with sym. and entry0 (aa)



[*] ? offers a help menu, like so:

[0x00400a30]> a?
|Usage: a[abdefFghoprxstc] [...]
| aa[?]              analyze all (fcns + bbs) (aa0 to avoid sub renaming)
| ab [hexpairs]      analyze bytes
| abb [len]          analyze N basic blocks in [len] (section.size by default)
| ac [cycles]        analyze which op could be executed in [cycles]
| ad[?]              analyze data trampoline (wip)
| ad [from] [to]     analyze data pointers to (from-to)
| ae[?] [expr]       analyze opcode eval expression (see ao)
| af[?]              analyze Functions
| aF                 same as above, but using anal.depth=1
| ag[?] [options]    output Graphviz code
| ah[?]              analysis hints (force opcode size, ...)
| ai [addr]          address information (show perms, stack, heap, ...)
| an [name] [@addr]  show/rename/create whatever flag/function is used at addr
| ao[?] [len]        analyze Opcodes (or emulate it)
| aO[?] [len]        Analyze N instructions in M bytes
| ap                 find prelude for current offset
| ar[?]              like 'dr' but for the esil vm. (registers)
| as[?] [num]        analyze syscall using dbg.reg
| av[?] [.]          show vtables
| ax[?]              manage refs/xrefs (see also afx?)





[*] afl will show us functions, grep for main:

[0x00400a30]> afl | grep main
0x00400b4d    1 68           sym.main
0x00400e10   10 1007 -> 219  sym.__libc_start_main
0x00403870   39 661  -> 629  sym._nl_find_domain
0x00403b10  308 5366 -> 5301 sym._nl_load_domain
0x00415fe0    1 43           sym._IO_switch_to_main_get_area
0x0044cf00    1 8            sym._dl_get_dl_main_map
0x00470520    1 49           sym._IO_switch_to_main_wget_area
0x0048fae0    7 73   -> 69   sym._nl_finddomain_subfreeres
0x0048fb30   16 247  -> 237  sym._nl_unload_domain




[*] pdf (print disassembly function) main function will give the following output:

[0x00400a30]> pdf @main
            ;-- main:
/ (fcn) sym.main 68
|   sym.main ();
|           ; var int local_ch @ rbp-0xc
|           ; var int local_8h @ rbp-0x8
|           ; var int local_4h @ rbp-0x4
|              ; DATA XREF from 0x00400a4d (entry0)
|           0x00400b4d      55             push rbp
|           0x00400b4e      4889e5         mov rbp, rsp
|           0x00400b51      4883ec10       sub rsp, 0x10
|           0x00400b55      c745f4040000.  mov dword [local_ch], 4
|           0x00400b5c      c745f8050000.  mov dword [local_8h], 5
|           0x00400b63      8b55f4         mov edx, dword [local_ch]
|           0x00400b66      8b45f8         mov eax, dword [local_8h]
|           0x00400b69      01d0           add eax, edx
|           0x00400b6b      8945fc         mov dword [local_4h], eax
|           0x00400b6e      8b4dfc         mov ecx, dword [local_4h]
|           0x00400b71      8b55f8         mov edx, dword [local_8h]
|           0x00400b74      8b45f4         mov eax, dword [local_ch]
|           0x00400b77      89c6           mov esi, eax
|           0x00400b79      488d3d881409.  lea rdi, qword str.the_value_of_a_is__d__the_value_of_b_is__d_and_the_value_of_c_is__d ; 0x492008 ; "the value of a is %d, the value of b is %d and the value of c is %d"                                           
|           0x00400b80      b800000000     mov eax, 0
|           0x00400b85      e8f6ea0000     call sym.__printf
|           0x00400b8a      b800000000     mov eax, 0
|           0x00400b8f      c9             leave
\           0x00400b90      c3             ret




[*] From TryHackMe - notes on Assembly 

Initial Data Type	Suffix	Size (bytes)
	Byte		  b	     1
	Word		  w	     2
    Double Word		  l	     4
	Quad		  q	     8
 Single Precision	  s	     4
 Double Precision	  l	     8

When dealing with memory manipulation using registers, there are other cases to be considered:

(Rb, Ri) = MemoryLocation[Rb + Ri]
D(Rb, Ri) = MemoryLocation[Rb + Ri + D]
(Rb, Ri, S) = MemoryLocation(Rb + S * Ri]
D(Rb, Ri, S) = MemoryLocation[Rb + S * Ri + D]


leaq source, destination: this instruction sets destination to the address denoted by the expression in source
addq source, destination: destination = destination + source
subq source, destination: destination = destination - source
imulq source, destination: destination = destination * source
salq source, destination: destination = destination << source where << is the left bit shifting operator
sarq source, destination: destination = destination >> source where >> is the right bit shifting operator
xorq source, destination: destination = destination XOR source
andq source, destination: destination = destination & source
orq source, destination: destination = destination | source




[*] Back to our pdf @main - we want to add a break after variables are set, after memory has been allocated, and beginning of program execution:

[0x00400a30]> db 0x00400b55

//////notice the "b" for "break"

[0x00400a30]> pdf @main
            ;-- main:
/ (fcn) sym.main 68
|   sym.main ();
|           ; var int local_ch @ rbp-0xc
|           ; var int local_8h @ rbp-0x8
|           ; var int local_4h @ rbp-0x4
|              ; DATA XREF from 0x00400a4d (entry0)
|           0x00400b4d      55             push rbp
|           0x00400b4e      4889e5         mov rbp, rsp
|           0x00400b51      4883ec10       sub rsp, 0x10
|           0x00400b55 b    c745f4040000.  mov dword [local_ch], 4
|           0x00400b5c      c745f8050000.  mov dword [local_8h], 5
|           0x00400b63      8b55f4         mov edx, dword [local_ch]
|           0x00400b66      8b45f8         mov eax, dword [local_8h]
|           0x00400b69      01d0           add eax, edx
|           0x00400b6b      8945fc         mov dword [local_4h], eax
|           0x00400b6e      8b4dfc         mov ecx, dword [local_4h]
|           0x00400b71      8b55f8         mov edx, dword [local_8h]
|           0x00400b74      8b45f4         mov eax, dword [local_ch]
|           0x00400b77      89c6           mov esi, eax
|           0x00400b79      488d3d881409.  lea rdi, qword str.the_value_of_a_is__d__the_value_of_b_is__d_and_the_value_of_c_is__d ; 0x492008 ; "the value of a is %d, the value of b is %d and the value of c is %d"                                                                                                                                          
|           0x00400b80      b800000000     mov eax, 0
|           0x00400b85      e8f6ea0000     call sym.__printf
|           0x00400b8a      b800000000     mov eax, 0
|           0x00400b8f      c9             leave
\           0x00400b90      c3             ret





[*] Run prgram and check main

[0x00400a30]> dc
hit breakpoint at: 400b55
[0x00400b55]> pdf
            ;-- main:
            ;-- rax:
/ (fcn) sym.main 68
|   sym.main ();
|           ; var int local_ch @ rbp-0xc
|           ; var int local_8h @ rbp-0x8
|           ; var int local_4h @ rbp-0x4
|              ; DATA XREF from 0x00400a4d (entry0)
|           0x00400b4d      55             push rbp
|           0x00400b4e      4889e5         mov rbp, rsp
|           0x00400b51      4883ec10       sub rsp, 0x10
|           ;-- rip:
|           0x00400b55 b    c745f4040000.  mov dword [local_ch], 4
|           0x00400b5c      c745f8050000.  mov dword [local_8h], 5
|           0x00400b63      8b55f4         mov edx, dword [local_ch]
|           0x00400b66      8b45f8         mov eax, dword [local_8h]
|           0x00400b69      01d0           add eax, edx
|           0x00400b6b      8945fc         mov dword [local_4h], eax
|           0x00400b6e      8b4dfc         mov ecx, dword [local_4h]
|           0x00400b71      8b55f8         mov edx, dword [local_8h]
|           0x00400b74      8b45f4         mov eax, dword [local_ch]
|           0x00400b77      89c6           mov esi, eax
|           0x00400b79      488d3d881409.  lea rdi, qword str.the_value_of_a_is__d__the_value_of_b_is__d_and_the_value_of_c_is__d ; 0x492008 ; "the value of a is %d, the value of b is %d and the value of c is %d"                                                                                                                                          
|           0x00400b80      b800000000     mov eax, 0
|           0x00400b85      e8f6ea0000     call sym.__printf
|           0x00400b8a      b800000000     mov eax, 0
|           0x00400b8f      c9             leave
\           0x00400b90      c3             ret






[*]  Notice we ripped on our break point --> which is using local_ch variable. Let's dump the memory info into hex:

[0x00400b55]> px @ rbp-0xc
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x7fff10debfa4  0000 0000 1890 6b00 0000 0000 7018 4000  ......k.....p.@.
0x7fff10debfb4  0000 0000 1911 4000 0000 0000 0000 0000  ......@.........
0x7fff10debfc4  0000 0000 0000 0000 0100 0000 d8c0 de10  ................
0x7fff10debfd4  ff7f 0000 4d0b 4000 0000 0000 0000 0000  ....M.@.........
0x7fff10debfe4  0000 0000 0600 0000 5500 0000 5000 0000  ........U...P...
0x7fff10debff4  0700 0000 0000 0000 0000 0000 0000 0000  ................
0x7fff10dec004  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7fff10dec014  0000 0000 0000 0000 0000 0000 0004 4000  ..............@.
0x7fff10dec024  0000 0000 7c99 a1db cd64 54b7 1019 4000  ....|....dT...@.
0x7fff10dec034  0000 0000 0000 0000 0000 0000 1890 6b00  ..............k.
0x7fff10dec044  0000 0000 0000 0000 0000 0000 7c99 c194  ............|...
0x7fff10dec054  f045 aa48 7c99 d5ca cd64 54b7 0000 0000  .E.H|....dT.....
0x7fff10dec064  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7fff10dec074  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7fff10dec084  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7fff10dec094  0000 0000 0000 0000 0000 0000 0000 0000  ................




[*] Move on to the next instruction and print, notice we went from 0000 to 0400 on the first two bytes:

[0x00400b55]> ds
[0x00400b55]> px @ rbp-0xc
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x7ffc3f9f4734  0400 0000 1890 6b00 0000 0000 7018 4000  ......k.....p.@.
0x7ffc3f9f4744  0000 0000 1911 4000 0000 0000 0000 0000  ......@.........
0x7ffc3f9f4754  0000 0000 0000 0000 0100 0000 6848 9f3f  ............hH.?
0x7ffc3f9f4764  fc7f 0000 4d0b 4000 0000 0000 0000 0000  ....M.@.........
0x7ffc3f9f4774  0000 0000 0600 0000 5500 0000 5000 0000  ........U...P...
0x7ffc3f9f4784  0700 0000 0000 0000 0000 0000 0000 0000  ................
0x7ffc3f9f4794  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7ffc3f9f47a4  0000 0000 0000 0000 0000 0000 0004 4000  ..............@.
0x7ffc3f9f47b4  0000 0000 07a5 6b1e 64df 4249 1019 4000  ......k.d.BI..@.
0x7ffc3f9f47c4  0000 0000 0000 0000 0000 0000 1890 6b00  ..............k.
0x7ffc3f9f47d4  0000 0000 0000 0000 0000 0000 07a5 2ba0  ..............+.
0x7ffc3f9f47e4  daa0 bab6 07a5 1f0f 64df 4249 0000 0000  ........d.BI....
0x7ffc3f9f47f4  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7ffc3f9f4804  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7ffc3f9f4814  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7ffc3f9f4824  0000 0000 0000 0000 0000 0000 0000 0000  ................




[*] Move on to the next variable:

[0x00400b55]> px @ rbp-0x8
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x7ffc3f9f4738  0500 0000 0000 0000 7018 4000 0000 0000  ........p.@.....
0x7ffc3f9f4748  1911 4000 0000 0000 0000 0000 0000 0000  ..@.............
0x7ffc3f9f4758  0000 0000 0100 0000 6848 9f3f fc7f 0000  ........hH.?....
0x7ffc3f9f4768  4d0b 4000 0000 0000 0000 0000 0000 0000  M.@.............
0x7ffc3f9f4778  0600 0000 5500 0000 5000 0000 0700 0000  ....U...P.......
0x7ffc3f9f4788  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7ffc3f9f4798  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7ffc3f9f47a8  0000 0000 0000 0000 0004 4000 0000 0000  ..........@.....
0x7ffc3f9f47b8  07a5 6b1e 64df 4249 1019 4000 0000 0000  ..k.d.BI..@.....
0x7ffc3f9f47c8  0000 0000 0000 0000 1890 6b00 0000 0000  ..........k.....
0x7ffc3f9f47d8  0000 0000 0000 0000 07a5 2ba0 daa0 bab6  ..........+.....
0x7ffc3f9f47e8  07a5 1f0f 64df 4249 0000 0000 0000 0000  ....d.BI........
0x7ffc3f9f47f8  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7ffc3f9f4808  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7ffc3f9f4818  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x7ffc3f9f4828  0000 0000 0000 0000 0000 0000 0000 0000  ................




[*] Take a look at the next instruction, local_8h moves on to %eax. To see the value:

0x00400b55]> dr
rax = 0x00400b4d
rbx = 0x00400400
rcx = 0x0044ba90
rdx = 0x7ffc3f9f4878-
r8 = 0x00000000
r9 = 0x00000003
r10 = 0x00000002
r11 = 0x00000000
r12 = 0x00401910
r13 = 0x00000000
r14 = 0x006b9018
r15 = 0x00000000
rsi = 0x7ffc3f9f4868
rdi = 0x00000001
rsp = 0x7ffc3f9f4730
rbp = 0x7ffc3f9f4740
rip = 0x00400b63
rflags = 0x00000206
orax = 0xffffffffffffffff




[*] Running "ds" then "dr", we see that we have moved on to the next instruction, which should reveal 5:

[0x00400b55]> ds
[0x00400b55]> dr
rax = 0x00000005      <--
rbx = 0x00400400
rcx = 0x0044ba90
rdx = 0x00000004
r8 = 0x00000000
r9 = 0x00000003
r10 = 0x00000002
r11 = 0x00000000
r12 = 0x00401910
r13 = 0x00000000
r14 = 0x006b9018
r15 = 0x00000000
rsi = 0x7ffc3f9f4868
rdi = 0x00000001
rsp = 0x7ffc3f9f4730
rbp = 0x7ffc3f9f4740
rip = 0x00400b69
rflags = 0x00000206
orax = 0xffffffffffffffff



[*] Going back to our disassembled main, we see instructions after rip. These show the values in registers moving to variables

[0x00400b55]> pdf @ main
            ;-- main:
/ (fcn) sym.main 68
|   sym.main ();
|           ; var int local_ch @ rbp-0xc
|           ; var int local_8h @ rbp-0x8
|           ; var int local_4h @ rbp-0x4
|              ; DATA XREF from 0x00400a4d (entry0)
|           0x00400b4d      55             push rbp
|           0x00400b4e      4889e5         mov rbp, rsp
|           0x00400b51      4883ec10       sub rsp, 0x10
|           0x00400b55 b    c745f4040000.  mov dword [local_ch], 4
|           0x00400b5c      c745f8050000.  mov dword [local_8h], 5
|           0x00400b63      8b55f4         mov edx, dword [local_ch]
|           0x00400b66      8b45f8         mov eax, dword [local_8h]
|           ;-- rip:
|           0x00400b69      01d0           add eax, edx
|           0x00400b6b      8945fc         mov dword [local_4h], eax
|           0x00400b6e      8b4dfc         mov ecx, dword [local_4h]
|           0x00400b71      8b55f8         mov edx, dword [local_8h]
|           0x00400b74      8b45f4         mov eax, dword [local_ch]
|           0x00400b77      89c6           mov esi, eax
|           0x00400b79      488d3d881409.  lea rdi, qword str.the_value_of_a_is__d__the_value_of_b_is__d_and_the_value_of_c_is__d ; 0x492008 ; "the value of a is %d, the value of b is %d and the value of c is %d"                                                                                                                                          
|           0x00400b80      b800000000     mov eax, 0
|           0x00400b85      e8f6ea0000     call sym.__printf
|           0x00400b8a      b800000000     mov eax, 0
|           0x00400b8f      c9             leave
\           0x00400b90      c3             ret





[*] 0x00400b85 is to print the data stored
[*] 0x00400b80 clears the value of eax - sometimes stores values of functions.
[*] 0x00400b8a clears eax
[*] 0x00400b8f and 0x00400b90 leave main function and exit program

[*] To visualize, you can type in "V" and hit enter. Use "P" and "p" to switch views.
