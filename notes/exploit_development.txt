Exploit Development

[*] Memory Corruption
    Diagram:
        A number of parts arem issing from this diagram. We only care about these parts for now.

         Low Memory
    +------------------+
    |       Text       |
    +------------------+
    |       Data       |
    +------------------+
    |       Heap       |
    |        |         |
    |        |         |
    |        V         |
    +------------------+
    |                  |
    |  Unused Memory   |
    |                  |
    +------------------+
    |        ^         |
    |        |         |
    |        |         |
    |      Stack       |
    +------------------+
         High Memory

    x86 General Purpose Registers
        EIP - The instruction pointer
        ESP - Stack Pointer
        EBP - Base Pointer
        ESI - Source Index
        EDI - Destination Index
        EAX - Accumulator
        EBX - Base
        ECX - Counter
        EDX - Data

    The Stack
        Last In First Out (LIFO)
            Think "a stack of lunch trays"
                Dirty trays are stacked on top of each other,
                Dishwasher person will pull from top to clean them.
        Grows from High to Low Memory
        PUSH instruction puts data on the stack
        POP instruction removes fata from the stack (into a register)

    A Stack Frame
        Diagram

                    Low Memory
        +---------------------------------+
        |ESP                              |
        |         Main Stack Frame        |
        |                                 |
        |                                 |
        |EBP                              |
        +---------------------------------+
                    High Memory

    Calling Another Function
        "Main" calls another function
        When a function completes execution, we return back to "main"
        Before handing over control to function main,
        PUSHes its return address onto the stack.
        This creates a prologue for the next function, before execute.

    Another Stack Frame
        Diagram:

                    Low Memory
        +---------------------------------+
        |ESP                              |
        |                                 |
        |     function1's stack frame     |
        |                                 |
        |                                 |
        |EBP Saved EBP from main          |  "POP" 
        +---------------------------------+
        |          Return Address         |
        +---------------------------------+
        |                                 |
        |        main's stack frame       |
        |                                 |
        |                                 |
        +---------------------------------+
                    High Memory

    Example Overflow Test

        #include <string.h>
        #include <stdio.h>
        
        void overflowed() {
                printf("%s\n", "Execution Hijacked");
        }
        
        void function(char *str){
                char buffer[5];
                strcpy(buffer, str);
        }
        
        void main(int argc, char *argv[]) {
                function(argv[1]);
                printf("%s\n", "Executed normally");
        }

    GNU Compiler
        root@kali:~$ gcc -g -fno-stack-protector -o overflowtest overflowtest.c
        root@kali:~$ ls overflowtest*
        overflowtest  overflowtest.c
        
        root@kali:~$ ./overflowtest 
        Segmentation fault
        
        root@kali:~$ ./overflowtest AA
        Executed normally
        
        root@kali:~$ ./overflowtest AAAA
        Executed normally
        
        root@kali:~$ ./overflowtest AAAAA
        Executed normally
        
        root@kali:~$ ./overflowtest AAAAAA
        Executed normally
        Segmentation fault

    GDB Debugging
        My user has gdb-peda installed so halfway through I switched to show how detail works.
            The standard gdb did not reveal hex, gdb-peda spit out the entire stack until break.
        Keep in mind we have source code so we know which lines to call. This is not always going to happen obviously.

        root@kali:~$ gdb overflowtest
        GNU gdb (Debian 8.3.1-1) 8.3.1
        Copyright (C) 2019 Free Software Foundation, Inc.                                                      
        License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
        This is free software: you are free to change and redistribute it.
        There is NO WARRANTY, to the extent permitted by law.
        Type "show copying" and "show warranty" for details.
        This GDB was configured as "x86_64-linux-gnu".
        Type "show configuration" for configuration details.
        For bug reporting instructions, please see:
        <http://www.gnu.org/software/gdb/bugs/>.
        Find the GDB manual and other documentation resources online at:
            <http://www.gnu.org/software/gdb/documentation/>.

        For help, type "help".
        Type "apropos word" to search for commands related to "word"...
        Reading symbols from overflowtest...
        (gdb) list 1,16                                       <-- Call lines 1 through 16
        1       #include <string.h>
        2       #include <stdio.h>
        3
        4       void overflowed() {
        5               printf("%s\n", "Execution Hijacked");
        6       }
        7
        8       void function(char *str){
        9               char buffer[5];
        10              strcpy(buffer, str);
        11      }
        12
        13      void main(int argc, char *argv[]) {
        14              function(argv[1]);
        15              printf("%s\n", "Executed normally");
        16      }

        (gdb) break 14                                         <-- Breakpoints will stop the program from continuing.
        Breakpoint 1 at 0x1189: file overflowtest.c, line 14.
        (gdb) break 10
        Breakpoint 2 at 0x1164: file overflowtest.c, line 10.
        (gdb) break 11
        Breakpoint 3 at 0x1177: file overflowtest.c, line 11.

        (gdb) run AAAA
        Starting program: /root/overflowtest AAAA
        
        Breakpoint 1, main (argc=2, argv=0x7fffffffe1f8) at overflowtest.c:14
        14              function(argv[1]);

            #  help keyword, we are looking at "x" (examine)
            #  The format "x/16xw $esp" translate to "examine/16hexwords $esp pointer"

        (gdb) help x
        Examine memory: x/FMT ADDRESS.
        ADDRESS is an expression for the memory address to examine.
        FMT is a repeat count followed by a format letter and a size letter.
        Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),
          t(binary), f(float), a(address), i(instruction), c(char), s(string)
          and z(hex, zero padded on the left).
        Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).
        The specified number of objects of the specified size are printed
        according to the format.  If a negative number is specified, memory is
        examined backward from the address.
        
        Defaults for format and size letters are those previously used.
        Default count is 1.  Default address is following last thing printed
        with this command or "print".
        (gdb) x/16xw $esp
        (gdb) x/16xw $esp
        0xffffffffffffe140:     Cannot access memory at address 0xffffffffffffe140

            #  SWITCH TO GDB-PEDA

        gdb-peda$ break 14                                                                                                                                        
        Breakpoint 1 at 0x1189: file overflowtest.c, line 14.                                                                                                     
        gdb-peda$ break 10                                                                                                                                        
        Breakpoint 2 at 0x1164: file overflowtest.c, line 10.                                                                                                     
        gdb-peda$ break 11
        Breakpoint 3 at 0x1177: file overflowtest.c, line 11.         
        gdb-peda$ run AAAA
        Starting program: /home/root/overflowtest AAAA
        [----------------------------------registers-----------------------------------]
        RAX: 0x55555555517a (<main>:    push   rbp)
        RBX: 0x0 
        RCX: 0x7ffff7fa9718 --> 0x7ffff7faba40 --> 0x0 
        RDX: 0x7fffffffe250 --> 0x7fffffffe548 ("SHELL=/bin/bash")
        RSI: 0x7fffffffe238 --> 0x7fffffffe526 ("/home/root/overflowtest")
        RDI: 0x2 
        RBP: 0x7fffffffe150 --> 0x5555555551b0 (<__libc_csu_init>:      push   r15)
        RSP: 0x7fffffffe140 --> 0x7fffffffe238 --> 0x7fffffffe526 ("/home/root/overflowtest")
        RIP: 0x555555555189 (<main+15>: mov    rax,QWORD PTR [rbp-0x10])
        R8 : 0x7ffff7faba50 --> 0x4 
        R9 : 0x7ffff7fe3780 (<_dl_fini>:        push   rbp)
        R10: 0x0 
        R11: 0x22 ('"')
        R12: 0x555555555060 (<_start>:  xor    ebp,ebp)
        R13: 0x7fffffffe230 --> 0x2 
        R14: 0x0 
        R15: 0x0
        EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)
        [-------------------------------------code-------------------------------------]
           0x55555555517e <main+4>:     sub    rsp,0x10
           0x555555555182 <main+8>:     mov    DWORD PTR [rbp-0x4],edi
           0x555555555185 <main+11>:    mov    QWORD PTR [rbp-0x10],rsi
        => 0x555555555189 <main+15>:    mov    rax,QWORD PTR [rbp-0x10]
           0x55555555518d <main+19>:    add    rax,0x8
           0x555555555191 <main+23>:    mov    rax,QWORD PTR [rax]
           0x555555555194 <main+26>:    mov    rdi,rax
           0x555555555197 <main+29>:    call   0x555555555158 <function>
        [------------------------------------stack-------------------------------------]
        0000| 0x7fffffffe140 --> 0x7fffffffe238 --> 0x7fffffffe526 ("/home/root/overflowtest")
        0008| 0x7fffffffe148 --> 0x200000000 
        0016| 0x7fffffffe150 --> 0x5555555551b0 (<__libc_csu_init>:     push   r15)
        0024| 0x7fffffffe158 --> 0x7ffff7e16bbb (<__libc_start_main+235>:       mov    edi,eax)
        0032| 0x7fffffffe160 --> 0x0 
        0040| 0x7fffffffe168 --> 0x7fffffffe238 --> 0x7fffffffe526 ("/home/root/overflowtest")
        0048| 0x7fffffffe170 --> 0x200200000 
        0056| 0x7fffffffe178 --> 0x55555555517a (<main>:        push   rbp)
        [------------------------------------------------------------------------------]
        Legend: code, data, rodata, value
        
        Breakpoint 1, main (argc=0x2, argv=0x7fffffffe238) at overflowtest.c:14
        14              function(argv[1]);
        gdb-peda$ x/16xw $esp
        0xffffffffffffe140:     Cannot access memory at address 0xffffffffffffe140
        gdb-peda$ x/xw $esp
        0xffffffffffffe140:     Cannot access memory at address 0xffffffffffffe140
        gdb-peda$ x/xw $ebp
        0xffffffffffffe150:     Cannot access memory at address 0xffffffffffffe150
        gdb-peda$ continue
        Continuing.
        [----------------------------------registers-----------------------------------]
        RAX: 0x7fffffffe543 --> 0x4548530041414141 ('AAAA')
        RBX: 0x0 
        RCX: 0x7ffff7fa9718 --> 0x7ffff7faba40 --> 0x0 
        RDX: 0x7fffffffe250 --> 0x7fffffffe548 ("SHELL=/bin/bash")
        RSI: 0x7fffffffe238 --> 0x7fffffffe526 ("/home/root/overflowtest")
        RDI: 0x7fffffffe543 --> 0x4548530041414141 ('AAAA')
        RBP: 0x7fffffffe130 --> 0x7fffffffe150 --> 0x5555555551b0 (<__libc_csu_init>:   push   r15)
        RSP: 0x7fffffffe110 --> 0x4d00000000 ('')
        RIP: 0x555555555164 (<function+12>:     mov    rdx,QWORD PTR [rbp-0x18])
        R8 : 0x7ffff7faba50 --> 0x4 
        R9 : 0x7ffff7fe3780 (<_dl_fini>:        push   rbp)
        R10: 0x0 
        R11: 0x22 ('"')
        R12: 0x555555555060 (<_start>:  xor    ebp,ebp)
        R13: 0x7fffffffe230 --> 0x2 
        R14: 0x0 
        R15: 0x0
        EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)
        [-------------------------------------code-------------------------------------]
           0x555555555159 <function+1>: mov    rbp,rsp
           0x55555555515c <function+4>: sub    rsp,0x20
           0x555555555160 <function+8>: mov    QWORD PTR [rbp-0x18],rdi
        => 0x555555555164 <function+12>:        mov    rdx,QWORD PTR [rbp-0x18]
           0x555555555168 <function+16>:        lea    rax,[rbp-0x5]
           0x55555555516c <function+20>:        mov    rsi,rdx
           0x55555555516f <function+23>:        mov    rdi,rax
           0x555555555172 <function+26>:        call   0x555555555030 <strcpy@plt>
        [------------------------------------stack-------------------------------------]
        0000| 0x7fffffffe110 --> 0x4d00000000 ('')
        0008| 0x7fffffffe118 --> 0x7fffffffe543 --> 0x4548530041414141 ('AAAA')
        0016| 0x7fffffffe120 --> 0x0 
        0024| 0x7fffffffe128 --> 0x0 
        0032| 0x7fffffffe130 --> 0x7fffffffe150 --> 0x5555555551b0 (<__libc_csu_init>:  push   r15)
        0040| 0x7fffffffe138 --> 0x55555555519c (<main+34>:     lea    rdi,[rip+0xe74]        # 0x555555556017)
        0048| 0x7fffffffe140 --> 0x7fffffffe238 --> 0x7fffffffe526 ("/home/root/overflowtest")
        0056| 0x7fffffffe148 --> 0x200000000 
        [------------------------------------------------------------------------------]
        Legend: code, data, rodata, value
        
        Breakpoint 2, function (str=0x7fffffffe543 "AAAA") at overflowtest.c:10
        10              strcpy(buffer, str);
        gdb-peda$ x/16xw $esp
        0xffffffffffffe110:     Cannot access memory at address 0xffffffffffffe110
        gdb-peda$ x/xw $ebp
        0xffffffffffffe130:     Cannot access memory at address 0xffffffffffffe130
        gdb-peda$ disassemble main                                        <-- disassembly!
        Dump of assembler code for function main:
           0x000055555555517a <+0>:     push   rbp
           0x000055555555517b <+1>:     mov    rbp,rsp
           0x000055555555517e <+4>:     sub    rsp,0x10
           0x0000555555555182 <+8>:     mov    DWORD PTR [rbp-0x4],edi
           0x0000555555555185 <+11>:    mov    QWORD PTR [rbp-0x10],rsi
           0x0000555555555189 <+15>:    mov    rax,QWORD PTR [rbp-0x10]
           0x000055555555518d <+19>:    add    rax,0x8
           0x0000555555555191 <+23>:    mov    rax,QWORD PTR [rax]
           0x0000555555555194 <+26>:    mov    rdi,rax
           0x0000555555555197 <+29>:    call   0x555555555158 <function>
           0x000055555555519c <+34>:    lea    rdi,[rip+0xe74]        # 0x555555556017
           0x00005555555551a3 <+41>:    call   0x555555555040 <puts@plt>
           0x00005555555551a8 <+46>:    nop
           0x00005555555551a9 <+47>:    leave  
           0x00005555555551aa <+48>:    ret    
        End of assembler dump.
        gdb-peda$ set disassembly-flavor intel                         <-- Set the flavor to intel for formatting
        
        gdb-peda$ continue                                             <-- Continue executing to the next breakpoint
        Continuing.
        [----------------------------------registers-----------------------------------]
        RAX: 0x7fffffffe12b --> 0xffe1500041414141 
        RBX: 0x0 
        RCX: 0x41414141 ('AAAA')
        RDX: 0x4 
        RSI: 0x7fffffffe543 --> 0x4548530041414141 ('AAAA')
        RDI: 0x7fffffffe12b --> 0xffe1500041414141 
        RBP: 0x7fffffffe130 --> 0x7fffffffe150 --> 0x5555555551b0 (<__libc_csu_init>:   push   r15)
        RSP: 0x7fffffffe110 --> 0x4d00000000 ('')
        RIP: 0x555555555177 (<function+31>:     nop)
        R8 : 0x7ffff7faba50 --> 0x4 
        R9 : 0x7ffff7fe3780 (<_dl_fini>:        push   rbp)
        R10: 0xfffffffffffff9ec 
        R11: 0x7ffff7f6eb40 --> 0xfff205a0fff20590 
        R12: 0x555555555060 (<_start>:  xor    ebp,ebp)
        R13: 0x7fffffffe230 --> 0x2 
        R14: 0x0 
        R15: 0x0
        EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)
        [-------------------------------------code-------------------------------------]
           0x55555555516c <function+20>:        mov    rsi,rdx
           0x55555555516f <function+23>:        mov    rdi,rax
           0x555555555172 <function+26>:        call   0x555555555030 <strcpy@plt>
        => 0x555555555177 <function+31>:        nop
           0x555555555178 <function+32>:        leave  
           0x555555555179 <function+33>:        ret    
           0x55555555517a <main>:       push   rbp
           0x55555555517b <main+1>:     mov    rbp,rsp
        [------------------------------------stack-------------------------------------]
        0000| 0x7fffffffe110 --> 0x4d00000000 ('')
        0008| 0x7fffffffe118 --> 0x7fffffffe543 --> 0x4548530041414141 ('AAAA')
        0016| 0x7fffffffe120 --> 0x0 
        0024| 0x7fffffffe128 --> 0x41414141000000 ('')
        0032| 0x7fffffffe130 --> 0x7fffffffe150 --> 0x5555555551b0 (<__libc_csu_init>:  push   r15)
        0040| 0x7fffffffe138 --> 0x55555555519c (<main+34>:     lea    rdi,[rip+0xe74]        # 0x555555556017)
        0048| 0x7fffffffe140 --> 0x7fffffffe238 --> 0x7fffffffe526 ("/home/root/overflowtest")
        0056| 0x7fffffffe148 --> 0x200000000 
        [------------------------------------------------------------------------------]
        Legend: code, data, rodata, value
        
        Breakpoint 3, function (str=0x7fffffffe543 "AAAA") at overflowtest.c:11
        11      }
        gdb-peda$ x/16xw $esp                                              <-- $esp wont print, need to find correct registers for Kali
        0xffffffffffffe110:     Cannot access memory at address 0xffffffffffffe110
        gdb-peda$ x/16xw $rip                                              <-- Examining the RIP worked 
        0x555555555177 <function+31>:   0x55c3c990      0x48e58948      0x8910ec83      0x8948fc7d
        0x555555555187 <main+13>:       0x8b48f075      0x8348f045      0x8b4808c0      0xc7894800
        0x555555555197 <main+29>:       0xffffbce8      0x3d8d48ff      0x00000e74      0xfffe98e8
        0x5555555551a7 <main+45>:       0xc3c990ff      0x00441f0f      0x4c574100      0x2c2f3d8d
        gdb-peda$ x/16xw $r10
        0xfffffffffffff9ec:     Cannot access memory at address 0xfffffffffffff9ec
        gdb-peda$ continue                                                <-- Moving on to complete the script
        Continuing.
        Executed normally
        [Inferior 1 (process 21701) exited with code 022]
        Warning: not running
